module analysis/statements

imports
  signatures/c-syntax-sig
  
  analysis/declarations
  analysis/expressions
  analysis/types

rules
  compStmtOk : scope * CompoundStatement
  compStmtOk(s, Compound(blockItems)) :- {s_block}
    new s_block,
    s_block -P-> s,
    s -F-> s_block,
    blockItemsOk(s_block, blockItems).
  
  stmtOk : scope * Statement
  stmtOk(s, Label(id, stmt)) :-
    declareLabel(s, id),
    stmtOk(s, stmt).
  stmtOk(_, stmt) :-
    stmt != Case(_, _) | error "'case' statement not in switch statement" @stmt,
    stmt != Default(_) | error "'default' statement not in switch statement" @stmt.
  stmtOk(s, Exp(e)) :- {T}
    typeOfExp(s, e) == T.
//  try { T == VOID() } | warning $[Expression result of type [T] discarded]. // Clutters assignments
  stmtOk(s, If(e, then)) :- {T}
    typeOfExp(s, e) == T,
    scalarType(T),
    stmtOk(s, then).
  stmtOk(s, IfElse(e, then, else)) :- {T}
    typeOfExp(s, e) == T,
    scalarType(T),
    stmtOk(s, then),
    stmtOk(s, else).
  stmtOk(s, Switch(e, case)) :- {T} // TODO switch should not accept _Bool, which is an int type now.
    typeOfExp(s, e) == T,
    intType(T) | error $[statement requires expression of integer type ('[T]' invalid)] @e, // switch should have int type
    switchCaseOk(s, T, Statement2BlockItem(case)).
  stmtOk(s, Switch(e, CompoundStatement2Statement(Compound(cases)))) :- {T}
    typeOfExp(s, e) == T,
    intType(T) | error $[statement requires expression of integer type ('[T]' invalid)] @e, // switch should have int type
    switchCasesOk(s, T, cases).
  stmtOk(s, While(e, body)) :-
    typeOfExp(s, e) == _,
    stmtOk(s, body).
  stmtOk(s, DoWhile(body, e)) :-
    typeOfExp(s, e) == _,
    stmtOk(s, body).
  stmtOk(s, For(InitClause2InitClause-OPT(init), Exp2Exp-OPT(e1), Exp2Exp-OPT(e2), body)) :- {s_for T}
    new s_for,
    s_for -P-> s,
    s -F-> s_for,
    initClauseOk(s_for, init),
    typeOfExp(s_for, e1) == T,
    scalarType(T), // TODO condition should be intType?
    typeOfExp(s_for, e2) == _. // TODO type does not matter?
  stmtOk(s, Goto(id)) :-
    resolveLabel(s, id).
  stmtOk(s, Return(Exp2Exp-OPT(e))) :- {T Tr}
    typeOfExp(s, e) == T,
    type of Return{} in s |-> [(_, (Return{}, Tr))],
    Tr != VOID() | error $[void function 'x' should not return a value (of type [Tr])].
  stmtOk(s, Return(NoExp())) :-
    type of Return{} in s |-> [(_, (Return{}, VOID()))]  | error "non-void function 'x' should return a value".
  stmtOk(s, CompoundStatement2Statement(compStmt)) :-
    compStmtOk(s, compStmt).

  blockItemOk : scope * BlockItem
  blockItemsOk maps blockItemOk(*, list(*))
  blockItemOk(s, Declaration2BlockItem(decl)) :-
    declOk(s, decl).
  blockItemOk(s, Statement2BlockItem(stmt)) :-
    stmtOk(s, stmt).
  
  switchCaseOk : scope * TYPE * BlockItem
  switchCasesOk maps switchCaseOk(*, *, list(*))
  switchCaseOk(s, T, Statement2BlockItem(Case(Exp2ConstExp(e), stmt))) :- {Te} // Check if const matches switch type
    stmtOk(s, stmt),
    typeOfExp(s, e) == Te,
    lub(T, Te) == T.
  switchCaseOk(s, _, Statement2BlockItem(Default(stmt))) :-
    stmtOk(s, stmt).
  switchCaseOk(s, _, bi) :- 
    blockItemOk(s, bi).
  