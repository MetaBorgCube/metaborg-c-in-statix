module analysis/declarations

imports
  signatures/c-syntax-sig

  analysis/expressions
  analysis/statements
  analysis/types

signature
  namespaces
    Var      : ID
    Typedef  : ID
    Label    : ID
    Return   :

  relations
    type : occurrence -> TYPE

  name-resolution labels P F
    resolve Var filter P* min $ < P
    resolve Typedef filter P* min $ < P
    resolve Label filter P* F* min $ < P, $ < F, F < P
    resolve Return filter P* min $ < P


rules
  translationUnitOk : TranslationUnit
  translationUnitOk(TranslationUnit(extDecls)) :- {s}
    new s,
    extDeclListOk(s, extDecls).

  extDeclOk : scope * ExternalDeclaration
  extDeclListOk maps extDeclOk(*, list(*))
  extDeclOk(s, FunctionDefinition2ExternalDeclaration(funDef)) :-
    funDefOk(s, funDef).
  extDeclOk(s, Declaration2ExternalDeclaration(decl)) :-
    declOk(s, decl).

  // FunDef : list(DeclarationSpecifier) * Declarator * list(Declaration) * CompoundStatement -> FunctionDefinition
  funDefOk : scope * FunctionDefinition
  funDefOk(s, FunDef(declSpecs, Declarator(NoPointer(), FunDeclTyped(IdDecl(id), ParamList(params))), decls, compStmt)) :- {s_fun T}
    declSpecsToType(s, declSpecs) == T,
    new s_fun,
    s_fun -P-> s,
    s_fun -> Return{} with type T,
    paramsOk(s, s_fun, params),
    declsOk(s_fun, decls),
    compStmtOk(s_fun, compStmt),
    declareVar(s, id, T).
    
  initClauseOk : scope * InitClause
  initClauseOk(s, Exp2InitClause(e)) :-
    typeOfExp(s, e) == _. // TODO more constraints on this?
//  initClauseOk(s, ForInitDecl(declSpecs, initDeclrtrs)) :- {t T ids}
//    declSpecsToType(s, declSpecs) == T, // specified type
//    initDeclrtrsOk(s, T, initDeclrtrs) == ids,
//    declareVars(s, ids, T).
  
  initDeclrtrOk : scope * TYPE * InitDeclarator -> ID
  // TODO Instead of AssignExp, a list of AssignExps can also occur (array initializer)
  // TODO When assigning, types do not have to match exactly. For example, assignments between int types are (mostly) allowed.
  initDeclrtrOk(s, T, InitDecl(decl, AssignExp2Initializer(Exp2AssignExp(e)))) = id :- {T'}
    declrtrOk(s, decl) == id, // declared type
    typeOfExp(s, e) == T', // expression type
    T == T'.
  initDeclrtrOk(s, _, Declarator2InitDeclarator(decl)) = id :-
    declrtrOk(s, decl) == id.

  declrtrOk : scope * Declarator -> ID
  // TODO Handle A LOT of other cases
  // Probably pass type from above and declare the variable in this rule
  declrtrOk(s, Declarator(_, IdDecl(id))) = id.
  declrtrOk(s, Declarator(_, DeclBracket(declrtr))) = declrtrOk(s, declrtr).
//  declrtrOk(s, Declarator(NoPointer(), ArrayDecl())). // TODO

  abstDeclrtrOk : scope * AbstractDeclarator

  paramOk : scope * scope * ParameterDeclaration
  paramsOk maps paramOk(*, *, list(*))
  paramOk(s, s_fun, ParamDecl1(declSpecs, declrtr@Declarator(p, _))) :- {id T Tu}
    declSpecsToType(s, declSpecs) == Tu, // specified type
    typeOfPointer(p, Tu) == T,
    declrtrOk(s, declrtr) == id, // declared type
    declareVar(s_fun, id, T).
  paramOk(s, s_fun, ParamDecl2(declSpecs, NoAbstractDeclarator())).
  paramOk(s, s_fun, ParamDecl2(declSpecs, AbstractDeclarator2AbstractDeclarator-OPT(abstDeclrtr))). // TODO finish

  // Decl : list(DeclarationSpecifier) * list(InitDeclarator) -> Declaration
  declOk : scope * Declaration
  declsOk maps declOk(*, list(*))
  declOk(s, Decl(declSpecs, [i@Declarator2InitDeclarator(Declarator(p, _))])) :- {id Tu T}
    declSpecsToType(s, declSpecs) == Tu, // Assumption: there are *only* type specifiers in here
    typeOfPointer(p, Tu) == T,
    initDeclrtrOk(s, T, i) == id,
    declareVar(s, id, T).
  declOk(s, Decl(declSpecs, [i@InitDecl(Declarator(p, _), AssignExp2Initializer(Exp2AssignExp(ie)))])) :- {id Tu T Ti}
    declSpecsToType(s, declSpecs) == Tu, // Assumption: there are *only* type specifiers in here
    typeOfPointer(p, Tu) == T,
    initDeclrtrOk(s, T, i) == id,
    typeOfExp(s, ie) == Ti,
    lub(Ti, T) == T,
    declareVar(s, id, T).
    
  typeOfPointer : Pointer-OPT * TYPE -> TYPE
  typeOfPointer(NoPointer(), T) = T.
  typeOfPointer(Pointer2Pointer-OPT(Pointer(po, q)), T) = POINTER(typeOfPointer(po, T)).

  declSpecsToType : scope * list(DeclarationSpecifier) -> TYPE
  declSpecsToType(s, specs) = typeOfType(s, declSpecsToTypeSpecs(specs)).

  declSpecsToTypeSpecs : list(DeclarationSpecifier) -> list(TypeSpecifier)
  declSpecsToTypeSpecs([]) = [].
  declSpecsToTypeSpecs([TypeSpecifier2DeclarationSpecifier(ts) | dss]) = [ts | declSpecsToTypeSpecs(dss)].
  declSpecsToTypeSpecs([_ | dss]) = declSpecsToTypeSpecs(dss).

rules // declaring / resolving variables and functions
  declareVar : scope * ID * TYPE
  declareVars maps declareVar(*, list(*), *)
  declareVar(s, id, T) :-
    s -> Var{id} with type T,
    type of Var{id} in s |-> [(_, (Var{id}, _))] | error $[Variable [id] already defined].

  typeOfVar : scope * ID -> TYPE
  typeOfVar(s, id) = T :- {id'}
//    @id.ref := id', // was causing errors, explicated terms don't support annotations?
    type of Var{id} in s |-> [(_, (Var{id}, T))] | error $[Variable [id] not defined].

  declareTypedef : scope * ID * TYPE
  declareTypedef(s, id, T) :-
    s -> Typedef{id} with type T,
    type of Typedef{id} in s |-> [(_, (Typedef{id}, _))] | error $[Type [id] already defined].

  typeOfTypedef : scope * ID -> TYPE
  typeOfTypedef(s, id) = T :- {id'}
    @id.ref := id',
    type of Typedef{id} in s |-> [(_, (Typedef{id'}, T))] | error $[Type [id] not defined].

  declareLabel : scope * ID
  declareLabel(s, id) :-
    s -> Label{id},
    Label{id} in s |-> [(_, (Label{id}))] | error  $[redefinition of label [id]].

  resolveLabel : scope * ID
  resolveLabel(s, id) :- {id'}
    @id.ref := id',
    Label{id} in s |-> [(_, (Label{id'}))] | error  $[use of undeclared label [id]].
