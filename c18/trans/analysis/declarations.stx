module analysis/declarations

imports
  signatures/c-syntax-sig

  analysis/expressions
  analysis/statements
  analysis/types
  analysis/util-bool

signature
  namespaces
    Var      : ID
    StructOrUnion : ID
    FunSig   : ID
    Typedef  : ID
    Label    : ID
    Return   :

  relations
    type : occurrence -> TYPE

  name-resolution labels P F
    resolve Var filter P* min $ < P
    resolve StructOrUnion filter P* min $ < P
    resolve FunSig filter P* min $ < P
    resolve Typedef filter P* min $ < P
    resolve Label filter P* F* min $ < P, $ < F, F < P
    resolve Return filter P* min $ < P


rules
  translationUnitOk : TranslationUnit
  translationUnitOk(TranslationUnit(extDecls)) :- {s}
    new s,
    extDeclListOk(s, extDecls).

  extDeclOk : scope * ExternalDeclaration
  extDeclListOk maps extDeclOk(*, list(*))
  extDeclOk(s, FunctionDefinition2ExternalDeclaration(funDef)) :-
    funDefOk(s, funDef).
  extDeclOk(s, Declaration2ExternalDeclaration(decl)) :-
    declOk(s, decl).

  // FunDef : list(DeclarationSpecifier) * Declarator * list(Declaration) * CompoundStatement -> FunctionDefinition
  funDefOk : scope * FunctionDefinition
  funDefOk(s, FunDef(declSpecs, Declarator(p, FunDeclTyped(IdDecl(id), ParamList(params))), decls, compStmt)) :- {s_fun paramIDs paramTs retT retTu qRes}
    declSpecsToType(s, declSpecs) == retTu,
    typeOfPointer(p, retTu) == retT,
    new s_fun,
    s_fun -P-> s,
    s_fun -> Return{} with type retT,
    paramsOk(s, params) == (paramIDs, paramTs),
    declsOk(s_fun, decls),
    compStmtOk(s_fun, compStmt),
    defineFun(s, id, paramTs, retT),
    declareVars(s_fun, paramIDs, paramTs).

  initClauseOk : scope * InitClause
  initClauseOk(s, Exp2InitClause(e)) :-
    typeOfExp(s, e) == _. // TODO more constraints on this?
//  initClauseOk(s, ForInitDecl(declSpecs, initDeclrtrs)) :- {t T ids}
//    declSpecsToType(s, declSpecs) == T, // specified type
//    initDeclrtrsOk(s, T, initDeclrtrs) == ids,
//    declareVars(s, ids, T).
  
  initDeclrtrOk : scope * TYPE * InitDeclarator -> ID
  // TODO Instead of AssignExp, a list of AssignExps can also occur (array initializer)
  // TODO When assigning, types do not have to match exactly. For example, assignments between int types are (mostly) allowed.
  initDeclrtrOk(s, T, InitDecl(decl, AssignExp2Initializer(Exp2AssignExp(e)))) = id :- {T'}
    declrtrOk(s, decl) == id, // declared type
    typeOfExp(s, e) == T', // expression type
    lub(T, T') == T.
  initDeclrtrOk(s, _, Declarator2InitDeclarator(decl)) = id :-
    declrtrOk(s, decl) == id.

  declrtrOk : scope * Declarator -> ID
  // TODO Handle A LOT of other cases
  // Probably pass type from above and declare the variable in this rule
  declrtrOk(s, Declarator(_, IdDecl(id))) = id.
  declrtrOk(s, Declarator(_, DeclBracket(declrtr))) = declrtrOk(s, declrtr).
  declrtrOk(s, Declarator(_, ArrayDecl(IdDecl(id), _))) = id. // TODO

  abstDeclrtrOk : scope * AbstractDeclarator

  paramOk : scope * ParameterDeclaration -> (ID * TYPE)
  paramsOk maps paramOk(*, list(*)) = (list(*), list(*))
  paramOk(s, ParamDecl1(declSpecs, declrtr@Declarator(p, _))) = (id, T) :- {Tu}
    declSpecsToType(s, declSpecs) == Tu, // specified type
    typeOfPointer(p, Tu) == T,
    declrtrOk(s, declrtr) == id. // declared type
  paramOk(s, ParamDecl2(declSpecs, NoAbstractDeclarator())) = ("", T) :- // ID is not known nor used
    declSpecsToType(s, declSpecs) == T.
  paramOk(s, ParamDecl2(declSpecs, AbstractDeclarator2AbstractDeclarator-OPT(Pointer2AbstractDeclarator(p)))) = ("", T) :- {Tu}
    declSpecsToType(s, declSpecs) == Tu,
    typeOfPointer(Pointer2Pointer-OPT(p), Tu) == T.

  // Decl : list(DeclarationSpecifier) * list(InitDeclarator) -> Declaration
  declOk : scope * Declaration
  declsOk maps declOk(*, list(*))
  declOk(s, Decl(declSpecs, [i@Declarator2InitDeclarator(Declarator(p, FunDeclTyped(IdDecl(id), ParamList(params))))])) :- {retTu retT paramTs s_fun qRes}
    declSpecsToType(s, declSpecs) == retTu,
    typeOfPointer(p, retTu) == retT,
    paramsOk(s, params) == (_, paramTs),
    declareFunSig(s, id, paramTs, retT).
  declOk(s, Decl(declSpecs, [i@Declarator2InitDeclarator(Declarator(p, _))])) :- {id Tu T}
    declSpecsToType(s, declSpecs) == Tu, // Assumption: there are *only* type specifiers in here
    typeOfPointer(p, Tu) == T,
    initDeclrtrOk(s, T, i) == id,
    declareVar(s, id, T).
  declOk(s, Decl(declSpecs, [i@InitDecl(Declarator(p, _), _)])) :- {id Tu T Ti}
    declSpecsToType(s, declSpecs) == Tu, // Assumption: there are *only* type specifiers in here
    typeOfPointer(p, Tu) == T,
    initDeclrtrOk(s, T, i) == id,
    declareVar(s, id, T).
    
  // Typedefs, structs, unions, enums
  declOk(s, Decl(declSpecs, [])) :-
    declSpecsToType(s, declSpecs) == _.
    
  typeOfPointer : Pointer-OPT * TYPE -> TYPE
  typeOfPointer(NoPointer(), T) = T.
  typeOfPointer(Pointer2Pointer-OPT(Pointer(po, q)), T) = POINTER(typeOfPointer(po, T)).

  declSpecsToType : scope * list(DeclarationSpecifier) -> TYPE
  declSpecsToType(s, specs) = typeOfType(s, declSpecsToTypeSpecs(specs)).

  declSpecsToTypeSpecs : list(DeclarationSpecifier) -> list(TypeSpecifier)
  declSpecsToTypeSpecs([]) = [].
  declSpecsToTypeSpecs([TypeSpecifier2DeclarationSpecifier(ts) | dss]) = [ts | declSpecsToTypeSpecs(dss)].
  declSpecsToTypeSpecs([_ | dss]) = declSpecsToTypeSpecs(dss).
  
  specQualsToDeclSpecs : list(SpecifierQualifier) -> list(DeclarationSpecifier)
  specQualsToDeclSpecs([]) = [].
  specQualsToDeclSpecs([TypeSpecifier2SpecifierQualifier(ts) | sqs]) = 
      [TypeSpecifier2DeclarationSpecifier(ts) | specQualsToDeclSpecs(sqs)].
  specQualsToDeclSpecs([TypeQualifier2SpecifierQualifier(tq) | sqs]) = 
      [TypeQualifier2DeclarationSpecifier(tq) | specQualsToDeclSpecs(sqs)].
  
rules typeOfStructOrUnionDecl : scope * StructOrUnion * TypeID-OPT * list(StructDeclaration) -> TYPE

  typeOfStructOrUnionDecl(s, Struct(), id, decls) = T :- {s_struct}
    new s_struct,
    structDeclsOk(s, s_struct, decls),
    STRUCT(s_struct) == T,
    defineStructOrUnion(s, id, T).
    
rules defineStructOrUnion : scope * TypeID-OPT * TYPE

  defineStructOrUnion(_, NoTypeID(), _).
  defineStructOrUnion(s, TypeID2TypeID-OPT(id), T) :- {id'}
    declareStructOrUnion(s, id, T).    
    
rules structDeclOk : scope * scope * StructDeclaration
  structDeclsOk maps structDeclOk(*, *, list(*))

  structDeclOk(s, s_struct, StructDecl(qs, decls)) :- {T}
    declSpecsToType(s, specQualsToDeclSpecs(qs)) == T,
    structMultiDeclOk(s, s_struct, T, decls).
    
  structUniDeclOk : scope * scope * TYPE * StructDeclarator
  structMultiDeclOk maps structUniDeclOk(*, *, *, list(*))
  
  structUniDeclOk(s, s_struct, t, Declarator2StructDeclarator(d@Declarator(p, _))) :- {id T}
    typeOfPointer(p, t) == T,
    declrtrOk(s_struct, d) == id,
    declareVar(s_struct, id, T).

rules // declaring / resolving variables and functions
  declareVar : scope * ID * TYPE
  declareVars maps declareVar(*, list(*), list(*))
  declareVar(s, id, T) :-
    s -> Var{id} with type T,
    type of Var{id} in s |-> [(_, (Var{id}, _))] | error $[Variable [id] already defined].

  typeOfVar : scope * ID -> TYPE
  typeOfVar(s, id) = T :- {id'}
//    @id.ref := id', // was causing errors, explicated terms don't support annotations?
    type of Var{id} in s |-> [(_, (Var{id}, T)) | _] | error $[Variable [id] not defined].

 /**
  * Definitie:
  * - genereer een declaratie voor de definitie met Def{_} namespace
  * - check dat het type overeenkomt met de 'dichtsbijzijnde' signature
  * - check dat er geen andere definitie is met dezelfde naam
  */
  defineFun : scope * ID * list(TYPE) * TYPE
  defineFun(s, id, paramTs, retT) :- {T}
    T == FUN(paramTs, retT),
    declareFunSig(s, id, paramTs, retT), // guarantee there's always a signature
    declareVar(s, id, T).

  /**
   * Signature:
   * - genereer een declaratie (unconditionally) met de Sig{_} namespace;
   *   er mogen meerdere declaraties van een naam zijn in scope graphs
   * - check dat andere declaraties met dezelfde naam hetzelfde type hebben
   */
  declareFunSig : scope * ID * list(TYPE) * TYPE
  declareFunSig(s, id, paramTs, retT) :- {T Ts results}
    T == FUN(paramTs, retT),
    s -> FunSig{id} with type T,
    type of FunSig{id} in s |-> results,
    Ts == queryResultsToTypes(results),
    equiTypes(T, Ts).

  equiType : TYPE * TYPE
  equiTypes maps equiType(*, list(*))
  equiType(Ta, Tb) :-
    Ta == Tb.

  queryResultToType : (path * (occurrence * TYPE)) -> TYPE
  queryResultsToTypes maps queryResultToType(list(*)) = list(*)
  queryResultToType((_, (_, T))) = T.

  typeOfFun : scope * ID -> (list(TYPE) * TYPE)
  typeOfFun(s, id) = (paramTs, retT) :- {id' T}
    @id.ref := id',
    type of FunSig{id} in s |-> [(_, (FunSig{id'}, T)) | _],
    T == FUN(paramTs, retT).

  declareTypedef : scope * ID * TYPE
  declareTypedef(s, id, T) :-
    s -> Typedef{id} with type T,
    type of Typedef{id} in s |-> [(_, (Typedef{id}, _))] | error $[Type [id] already defined].

  typeOfTypedef : scope * ID -> TYPE
  typeOfTypedef(s, id) = T :- {id'}
    @id.ref := id',
    type of Typedef{id} in s |-> [(_, (Typedef{id'}, T))] | error $[Type [id] not defined].

  declareLabel : scope * ID
  declareLabel(s, id) :-
    s -> Label{id},
    Label{id} in s |-> [(_, (Label{id}))] | error  $[redefinition of label [id]].

  resolveLabel : scope * ID
  resolveLabel(s, id) :- {id'}
    @id.ref := id',
    Label{id} in s |-> [(_, (Label{id'}))] | error  $[use of undeclared label [id]].
    
  declareStructOrUnion : scope * ID * TYPE
  declareStructOrUnion(s, id, T) :-
    s -> StructOrUnion{id} with type T,
    type of StructOrUnion{id} in s |-> [(_, (StructOrUnion{id}, _))] 
        | error $[Struct or union [id] already defined].
        
  typeOfStructOrUnion : scope * ID -> TYPE
  typeOfStructOrUnion(s, id) = T :- {id'}
    @id.ref := id',
    type of StructOrUnion{id} in s |-> [(_, (StructOrUnion{id'}, T))] 
        | error $[Struct or union [id] not defined]. 
