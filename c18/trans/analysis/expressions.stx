module analysis/expressions

imports
  analysis/declarations
  analysis/types

rules
  typeOfExp : scope * Exp -> TYPE
  typeOfExps maps typeOfExp(*, list(*)) = list(*)

  // TODO: do something with U/L/LL/UL/LU/LLU/ULL suffixes
  typeOfExp(_, Constant2Exp(IntegerConstant2Constant(_))) = INT().
  typeOfExp(_, Constant2Exp(CharacterConstant2Constant(_))) = INT().
  typeOfExp(_, Constant2Exp(FloatingConstant2Constant(_))) = FLOAT().
//  typeOfExp(_, String(_)) = STRING().
  typeOfExp(_, LChar(_)) = CHAR().

  typeOfExp(s, UnOp(op, e)) = T :- {Te}
    typeOfExp(s, e) == Te,
    typeOfUnExp(op, Te) == T.
  
//  typeOfExp(s, BinExp(op, e1, e2)) = T :- {T1 T2}
//    typeOfExp(s, e1) == T1,
//    typeOfExp(s, e2) == T2,
//    typeOfBinExp(op, T1, T2) == T.

  typeOfExp(s, Comma(e1, e2)) = typeOfExp(s, e2).
  
  typeOfExp(s, Assign(e1, op, e2)) = T :- {T2}
    typeOfExp(s, e1) == T,
    typeOfExp(s, e2) == T2,
    lub(T2, T) == T.
    
  typeOfExp(s, LAnd(e1, e2)) = INT() :-
    intType(typeOfExp(s, e1)),
    intType(typeOfExp(s, e2)).
    
  typeOfExp(s, Ior(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    numberRules(T1, T2) == T.
    
  typeOfExp(s, Eor(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    numberRules(T1, T2) == T.
    
  typeOfExp(s, And(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    numberRules(T1, T2) == T.
    
  typeOfExp(s, EqNeq(e1, op, e2)) = INT() :-
    intType(typeOfExp(s, e1)),
    intType(typeOfExp(s, e2)).
    
  typeOfExp(s, Order(e1, op, e2)) = INT() :-
    intType(typeOfExp(s, e1)),
    intType(typeOfExp(s, e2)).
    
  typeOfExp(s, Shift(e1, op, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    numberRules(T1, INT()) == T,
    intType(typeOfExp(s, e2)).
    
  typeOfExp(s, AddSub(e1, op, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    numberRules(T1, T2) == T.
    
  typeOfExp(s, MulDivMod(e1, op, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    numberRules(T1, T2) == T.
    
  typeOfExp(s, SizeofT(_)) = ULONGLONG().
  typeOfExp(s, AlignofT(_)) = ULONGLONG().

//  TODO: improve/desugar cast syntax?    
//  typeOfExp(s, Cast(TypedefName2(ts, a), e)) = T :-
//    typeOfType(s, ts) == T.

  

//  typeOfExp(s, Call(callee, args)) = Tr :- {Ta Ta'}
//    typeOfExp(s, callee) == FUNC(Ta, Tr), // i.e. int -> int
//    typeOfExps(s, args) == Ta' | error $[Function expects types [Ta], not [Ta']] @args,
//    Ta' == Ta.
//  typeOfExp(s, Proj(e, ID-LEX2ID(id))) = T :-
//    // lookup scope (type) of e
//    // find 'id' in scope and unify with T
//  typeOfExp(s, DerefProj(e, ID-LEX2ID(id))) = T :-
//    // lookup scope (type) of e
//    // find 'id' in scope and unify with T
  typeOfExp(s, Var(id)) = typeOfVar(s, id).

rules
  typeOfUnExp : UnaryOp * TYPE -> TYPE
//  typeOfUnExp(UnaryOp(), T). TODO
  typeOfUnExp(Sizeof(), _) = ULONGLONG. // actually size_t
  typeOfUnExp(Alignof(), _) = ULONGLONG. // actually size_t
//  typeOfUnExp(Subscript(), Te) = T :- // TODO if |-Te = int[], |-T=int

rules
  intRules : TYPE * TYPE -> TYPE
  intRules(T1, T2) = T :-
    lub(T1, T2) == T,
    intType(T).

rules
  numberRules : TYPE * TYPE -> TYPE
  numberRules(T1, T2) = intRules(T1, T2).
  numberRules(T, T) = T :-
    numberType(T).
